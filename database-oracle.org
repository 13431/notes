#+TITLE: Oracle 数据库


数据库本质是用计算机存储数据的一种系统。
它是位于 =用户= 和 =系统= 之间的一种管理软件。

* 序
1. 登录 SQLPLUS
   : cmd
   : sqlplus [用户名]/[密码][@数据库] [参数]
   : sqlplus sys/orcl as sysdba  -- 登录 sys 用户，必须指定 sysdba 或 sysoper 身份
   : sqlplus system/orcl         -- 数据库管理员

2. 创建一个自己的用户(比如 vip/vip)
   #+BEGIN_SRC sql
     create user vip identified by vip;     -- 注意，新创建的用户，什么权限都没有，需要授权后才能使用
     grant create session to vip;           -- 授予登录的权限
     grant connect to vip;                  -- 角色是很多权限的打包，connect 是一种角色，它包含了连接查看数据的一些基本权限
     grant dba to vip;                      -- dba 是绝大多数权限的集合，它基本能做所有事情，所以很少单独授予用户。但在测试环境中，这样，很爽。

     -- 上面的创建用户、授予权限两步操作，可以简化为下面一步：
     grant dba to vip identified by vip;    -- 注意，使用分号结尾
   #+END_SRC

3. 切换到用户
   : sqlplus vip/vip  -- 在 cmd 下
   : conn vip/vip     -- 在 sqlplus 中

4. 使用
   : create table aaa (id int);

5. 激活内置的测试账号，这里面有几张示例表，可以用它们练习下查询
   : alter user scott account unlock;
   : conn scott/tiger

6. 修改密码
   : alter user scott identified by [newpassword];

* 甜点
** 题库
- 在芝加哥工作的人中，谁的工资最高
- 查询每个部门下有多少员工
- 查询除去 salesman 所有平均工资超过 1500 的部门
- 查询在 new york 工作的所有员工的姓名，部门名称和工资信息
- 查询姓名为 King 的员工的编号，名称跟部门
- 查询各种工作的最低工资
- 查询工龄大于10年的所有员工信息
- 查询每个部门员工数量，平均工资和平均工作年限
- 统计各部门每个工种的人数，平均工资。
- 查询从事同一种工作但不属于同一部门的员工信息。
- 查询所有员工工资都大于1000的部门的信息及员工信息
- 查询入职日期早于其直接上级的所有员工信息。
- 列出雇员中（除去mgr为空的人)工资第二高的人。
- 列出1981年来公司所有员工的总收入（包括sal和comm）

** 查询各种工作中工资最低的人
看到最低、最大、平均之类的题目，首先想到的是分组函数的使用。

也就是 group by, having。

#+BEGIN_SRC sql
  select job, min(sal) from emp group by job;
#+END_SRC

** 在芝加哥工作的人中，谁的工资最高

[题目] 从 scott 用户的 emp/dept 表中，找到 “来自芝加哥最有钱的那个人” 。

首先，我们需要理清思路。

这里总共有两个条件：
1. 这个人来自芝加哥
2. 这个人是最有钱的，而且是芝加哥最有钱的

我们可以看出，第二个条件是依赖第一个条件的。

所以，分两步查询：
1. 找出所有来自芝加哥的人
2. 从这些人中，找到最有钱的那个。这一步，可以通过 max 函数或者 order by 方式实现。

*下面是语句示例：*
#+BEGIN_SRC sql

  ---- 第一步：找到来自芝加哥的所有人。下面两种写法等价：

  select e.* from emp e
    join dept d on (e.deptno=d.deptno)
    where d.loc='CHICAGO';

  select e.* from emp e, dept d
    where d.deptno = e.deptno
          and d.loc='CHICAGO';
  

  ---- 第二步，基于上面结果，筛选出最有钱的那个

  -- 可以通过 max 函数
  select e.* from emp e, dept d
    where e.deptno = d.deptno
          and d.loc='CHICAGO'
          and sal = 
              (select max(sal) from emp e, dept d
                where e.deptno = d.deptno
                      and d.loc='CHICAGO');

  -- 可以通过 order by 方式
  select ename from
    (select e.*, d.* from emp e, dept d
      where e.deptno = d.deptno
            and d.loc='CHICAGO'
      order by sal desc)
  where rownum = 1;

#+END_SRC

注意，实现的方式，不止上面的那些。但总体 *思路* 是一样的。

所以，思路永远是最重要的。


** 查询所有员工工资都大于1000的部门的信息及员工信息

*最核心的问题：* 查询出符合条件的部门编号。

*** 第一种思路
1. 查询出所有的部门编号
   : select * from emp;

2. 查询出所有工资少于 1000 的人，
   我们要把它所在的部门，从上面的结果中排除掉。
   : select deptno from emp where sal < 1000;

3. 将上面查询出的不符合条件的部门排除掉
   : select distinct deptno from emp
   :  where deptno not in 
   :   (select deptno from emp where sal < 1000);

4. 修改上面语句，增加最终的条件，查询所有的其他信息
   #+BEGIN_SRC sql
    select d.dname, e.* from emp e join dept d on(e.deptno = d.deptno)
      where e.deptno not in
        (select deptno from emp where sal < 1000)
   #+END_SRC


*** 第二种思路

使用分组函数(=group by= / =having=)。

分组函数主要用来统计分析。

一个完整的查询语句如下，其中 group by 和 having 是用来分组和筛选分组。
#+BEGIN_SRC sql
  select [字段] from [表名]
    where [条件]
    group by [分组字段]
    having [对分组结果进行筛选]
    order by [字段]
#+END_SRC

示例：
#+BEGIN_SRC sql
  select deptno,     -- 分组字段
         count(*),   -- 人数
         sum(sal),   -- 工资总和
         avg(sal),   -- 平均工资
         max(sal),   -- 最高工资
         min(sal)    -- 最低工资
    from emp group by deptno         -- 按照部门分组，进行统计
             having avg(sal) > 2000; -- 只显示平均工资大于 2000 的分组  
#+END_SRC


*那我们的题目的解决思路就是：*
1. 按照部门分组
   #+BEGIN_SRC sql
     select deptno from emp group by deptno;
   #+END_SRC

2. 筛选，排除最低工资小于 1000 的部门。
   即：得到符合条件的部门的编号。
   #+BEGIN_SRC sql
     select deptno from emp group by deptno having min(sal) > 1000;
   #+END_SRC

3. 完善最终语句，得到最终结果。
   #+BEGIN_SRC sql
     select * from emp e, dept d
       where e.deptno = d.deptno
             and e.deptno in (select deptno from emp group by deptno having min(sal) > 1000);
   #+END_SRC

* 冷饮
根据我们学校的实际情况，请帮助设计一个学生管理系统。
: 比如, 学生，老师，班级，课程。按照你自己的设计，酌情增加。

要求，先用 e-r 图，将实体的关系表述出来。

你可以用一些知名的工具去画，也可以手动在纸上画。

然后，将设计好的图，和生成的表的语句，一起上交。

* 体系结构
Oracle 采取的是 Client/Server 架构。

#+BEGIN_SRC dot :file assets/dot/oracle_cs.gif :exports results
  digraph OracleCS {
      rankdir=LR;
      node [margin=.6,shape=Mrecord];

      Client -> TNSListener -> Server;
      TNSListener [margin=.1,shape=plaintext];
  }
#+END_SRC

#+RESULTS:
[[file:assets/dot/oracle_cs.gif]]


客户端(=Client=)操作数据库的请求发送后，服务端的监听器(=TNSListener=)接收到请求，并将其转发给相应的数据库实例(=Instance=)，再由实例(=Instance=)去操纵数据库(=Database=)。
返回操作结果，是一个相反的过程。下面是个简陋的图示:

#+BEGIN_SRC dot :file assets/dot/oracle_construct.gif :exports results
  digraph OracleConstruct {
      bgcolor=antiquewhite;

      node [shape=Mrecord,fontname=SimSun,fontsize=10];
      edge [fontname=SimSun,fontsize=9,arrowhead=vee];

      subgraph cluster_c {
          label="Client";style=filled;color=khaki;
          Client [label = "{<sqlplus> sqlplus | SQL\nDeveloper |jdbc.jar | TOAD | PL/SQL\nDeveloper}", shape=record];
      }

      TNSListener;

      subgraph cluster_s {
          label="Server";style=filled;color=khaki;

          Instance [style=filled,fillcolor=skyblue,margin=.4];
          Database [style=filled,fillcolor=skyblue,margin=.4];

          Instance -> { SGA, "后台进程" } [arrowhead=none];
          Database -> dbfiles [label="物理组件"];
          Database -> dbdatas [label="逻辑组件"];

          {
             rank=same; Instance -> Database[color=red,label=" DBName ",fontcolor=blue];
          }

          dbfiles [label="{ 控制文件 | 数据文件 | 重做日志 | 归档日志 }"];
          dbdatas [label="{ 表空间\n(Tablespace) | 段(Segment) | 区(Extend) | 块(Block) }"];
      }

      Client -> TNSListener[bgcolor=blue,color=red,label="sqlplus\nvip/vip@192.168.0.111/orcl\n\nselect * from emp;",lhead=clusterC,fontcolor=blue];
      TNSListener -> Instance:w[color=red,headlabel=" SID  ",constraint=false,fontcolor=blue];

  }
#+END_SRC

#+RESULTS:
[[file:assets/dot/oracle_construct.gif]]

** Client
*** Sqlplus
这是一个轻量级的功能强大的客户端, 是 dba 必须掌握的工具。

用 =sqlplus= 连接数据库的语法为：
#+BEGIN_SRC sh
  # Usage:
  #   sqlplus 用户名/密码@主机名:端口号/实例名
  # 参数个数不是固定的

  sqlplus                         # 会要求你输入用户名密码，默认连接本地 ORACLE_SID 变量指定的数据库
  sqlplus vip                     # 会要求你输入密码
  sqlplus vip/vip                 # 连接本地 ORACLE_SID 变量指定的数据库

  sqlplus sys/hello as sysdba     # sys 用户必须用 sysdba 或 sysoper 的身份登录

  sqlplus vip@192.168.0.111/orcl  # 连接 192.168.0.111 机器上的 orcl 数据库，用户名为 vip
  sqlplus vip@192db               # 连接 别名 为 192db 的数据库
#+END_SRC

#+RESULTS:


我们可以配置 sqlplus 的一些行为，两个命令：
1. show. 用来显示配置参数
2. set.  用来设置配置参数

比如：
: show all               -- 显示所有配置参数
: show lines             -- 显示 lines 的配置信息
: show errors            -- 显示错误
: set lines[ize] 333     -- 将行宽设置为 333
: set pages[ize] 444     -- 将每页的记录数设置为 444
: set echo off/on        -- 导入外部文件，是否要显示原始 sql 语句
: set feedback on/off    -- 是否显示“查询到xx数据”等信息
: set timing on/off      -- 是否显示语句的执行时间
: set autocommit on/off  -- 是否启用自动提交
: set autotrace on/off   -- 是否输出执行计划
: set serveroutput on/off-- 是否显示来自服务端的信息
: column aaa format a22  -- 将列 'aaa' 的宽度限制为 22 个字幕'a'的大小。column 命令很强大，语句也复杂，此处不提。

在 sqlplus 中有缓冲区的概念:
: 缓冲区是用来记录上一次执行的命令语句的空间。

我们可以通过一些列简单命令，对上一次输入的语句进行一些控制:
- 增 =append/insert=
- 删 =delete=
- 改 =change=
- 查 =list=
- 执行修改后的语句 =run= 或者 =/=

例子：
: list         -- 显示完整的缓存区
: list 3       -- 显示并定位到第三行
: list 3 5     -- 显示第三行到第五行的内容
: list last    -- 定位到最后一行

: list 3
: del               -- 删除第三行

: list 3
: append  order by sal  -- 定位到第三行，然后追加 order by sal
: insert order by sal   -- 开启新的一行，插入 order by sal

: list 3
: change /emp/dept      -- 定位到第三行，将这一行的 emp 换为 dept

还有其他一些命令：
: get D:\aaa.sql        -- 将文件加载到缓冲区，但不执行
: start D:\aaa.sql      -- 将文件加载到缓冲区，并且执行
: @D:\aaa.sql           -- 是上面一条语句的简写形式
: save D:\bbb.sql       -- 将缓冲区的内容保存到文件中
: edit                  -- 调用外部编辑器，编辑缓冲区
: clear screen          -- 清空缓冲区

: show user             -- 显示当前用户
: show parameters       -- 显示 oracle 的配置参数
: show parameters nls   -- 显示 oracle 中所有跟语言配置相关的一些参数
: describe emp          -- 显示 emp 表的结构信息

*** JDBC
用 Java 连接数据库，需要用到 jdbc 驱动，它们可以在下面目录中找到：
: 主目录\product\12.1.0\dbhome_1\jdbc\lib\*.jar

比如 =ojdbc7_g.jar=, =7= 表示适用于 JDK 版本 1.7, =g= 表示自带更多调试信息。

** TNSListener

TNSListener，是用来监听来自客户端的请求，并将其转发给相对应的服务端实例的一种后台服务。

它是沟通客户端与服务端的一个桥梁。

比如，下面用 =sqlplus= 客户端将会连接 =localhost= 上的 =orcl= 数据库:
: sqlplus vip/vip@localhost/orcl

请求会发送到 localhost 主机的 1521 号端口，
作为监听的 TNSListener 收到这个请求后，再把请求转发给对应的 orcl 数据库实例。

所以必须开启监听服务，并且配置正确，才能连接操作数据库。
: 注：如果用 sqlplus vip/vip 的方式连接数据库，即没有指定连接的机器，那么默认连接的是本机数据库
: 这种连接是不需要监听服务的，因为为了增加连接速度，这样的本地连接 oracle 会使用一个专用的进程直接连接实例

我们可以使用 Oracle 提供的 =lsnrctl= 命令操纵监听服务的开启或关闭：
: lsnrctl status    # 查看状态
: lsnrctl stop      # 停止监听服务
: lsnrctl start     # 开启监听服务
: lsnrctl reload    # 重启监听服务
: lsnrctl services  # 查看监听的连接情况

我们可以使用 Oracle 的 Net Manager 工具来配置自己的监听器。

实质上，用 Net Manager 配置跟直接修改下面文件的作用是一样的：
: 主目录\product\12.1.0\dbhome_1\network\admin\listener.ora

我们在 Net Manager 中对 listener 的配置对应的是这一段代码：
#+BEGIN_EXAMPLE
LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = TCP)(HOST = 0.0.0.0)(PORT = 1521))
    )
    ...
  )
#+END_EXAMPLE

只要修改其中的 host/port 等，重启监听服务即可。

** Server
Oracle 服务端分为两部分：
1. =Instance= 实例
2. =Database= 数据库

*** 实例(Instance)
*实例*, 又称为数据库引擎，由 =SGA(System Global Area, 系统全局区)= 和 =一系列后台进程= 组成。
它需要启动才会生成，用来加载并管理一个数据库。

*服务启动的大致过程：*
1. [读取] 读取系统的 ORACLE_SID 环境变量，确定要启动的实例名字，比如为 xxoo
2. [加载] 从 =$ORABASE/admin/xxoo= 和 =$ORA_HOME/database/SPFILEXXOO.ora= 等位置加载相关配置文件。配置文件的名字是根据 sid 来定义的。
3. [启动] 从配置文件中，读取相关信息，比如数据库名字、数据库控制文件位置、SGA 等信息，并根据这些，初始化数据库加载需要的 =内存空间(SGA)= 和 =相关进程= 。
4. [装载] 根据配置文件中读取的数据库信息，找到各种数据文件位置，并装载数据库。
5. [启动] 进行数据校验等，如果没有问题，启动数据库。

可以通过查看启动过程协助理解：
#+BEGIN_SRC sql
  -- 首先，登录 sys 用户，只有管理员才有完全操纵数据库的权力
  -- shutdown 用来关闭。如果不带参数，默认为 normal
  ---- immediate 表示立即关闭，如果有未处理完操作，回滚并断开
  ---- normal 表示等待所有连接断开才关闭数据库
  ---- 其他参数，略
  shutdown immediate;

  -- 启动数据库，分解为三个动作：
  ---- 启动实例
  ---- 利用启动的实例去挂载数据库
  ---- 校验并打开数据库
  -- 只有完全打开，才能进行完全的数据操作
  -- 也可以指定参数，启动到某个阶段。这是在维护数据库中使用的命令。
  startup             -- 如果不加参数，
  startup nomount     -- 启动到 nomount 阶段
  startup mount       -- 启动到 mount 阶段

  -- 当然，也可以这样分步启动：
  startup nomount
  alter database mount
  alter database open
#+END_SRC

*** 数据库(Database)
*数据库*, 是保存在硬盘上的文件集合，它是数据的主要载体。
: $OracleBase\oradata\[数据库名字]\

可以从不同的角度去认识数据库，比如物理/逻辑角度：
**** 物理组件
数据库是保存在操作系统的一系列文件。

默认安装情况下，这些文件都在 =$ORACLE_BASE/oradata= 文件夹下：
#+BEGIN_EXAMPLE
oradata/
└── orcl [数据库的名字]
    ├── CONTROL01.CTL
    ├── CONTROL02.CTL
    ├── EXAMPLE01.DBF
    ├── REDO01.LOG
    ├── REDO02.LOG
    ├── REDO03.LOG
    ├── SYSAUX01.DBF
    ├── SYSTEM01.DBF
    ├── TEMP01.DBF
    ├── UNDOTBS01.DBF
    └── USERS01.DBF
#+END_EXAMPLE

从文件角度分析，一个数据库包含下面几类（组件）：
1. 控制文件(control file)。记录数据库的物理结构和其他信息，如数据库名称、各种文件位置等。多副本。
   : select * from v$controlfile;
2. 数据文件(data file)。用来存储数据的文件，会自动扩张。数据以块为单位进行保存。
   : select name, status, enabled from v$datafile;
3. 重做日志文件(redo log)。用来记录用户的所有操作，为了备份恢复。
   一个数据库至少有两个日志组，每个日志组至少有一个成员，成员之间是镜像关系。
   用户的操作会记录到 redo log 中，当一个组记录满了，会自动切换到下一个组。轮流循环。
   #+BEGIN_SRC sql
     -- 需要理解 Oracle 日志的思路:
     -- 它采取了【多个分组，轮流循环写入；每组多成员，互为镜像；保存更多信息，使用归档模式】的方式，保证了记录安全性。
     -- 在生产环境中，需要日志调整到不同的磁盘中，这样，即使某个文件损坏，或某块磁盘损坏，都可以通过镜像的日志文件对数据进行恢复。

     -- 查看 redo log 日志组
     select * from v$log;
     select * from v$logfile;

     -- 增加/删除 日志组
     alter database add  logfile 'd:/sss.rlog' size 100m;
     alter database drop logfile 'd:/sss.rlog';

     -- 清空日志组
     alter database clear logfile group 1;
     alter database clear unarchived logfile group 1;

     -- 为日志组 增加/删除 成员
     alter database add  logfile member 'd:/ssss.log' to group 1;
     alter database drop logfile member 'd:/ssss.log';
   
     -- 重命名文件
     -- 首先，在文件夹管理器里，将文件改名，比如，改为 ssss.redolog
     -- 其次，重启数据库到 mount 状态，然后执行重命名命令
     alter database rename file 'd:/ssss.log' to 'd:/ssss.redolog';

     -- 日志组一般是在写满的时候自动切换。
     -- 我们也可以手动切换
     alter system switch logfile;
   #+END_SRC
4. 归档日志文件。是重做日志的补充（redo log 记录的记录是有限的），可以把写满的 redo log 进行备份。
   #+BEGIN_SRC sql
     -- Oracle 的归档模式默认是关闭的
     -- 归档模式会占用大量空间
     -- 但他们用更多的空间，保存更多的历史记录，保障更大的安全性

     -- 查看状态
     archive log list;

     -- 切换数据库到归档模式
     alter database archivelog;

     -- 启动
     archive log start;

     -- 查看状态
     archive log list;
   #+END_SRC
5. 其他文件

**** 逻辑组件
https://docs.oracle.com/cd/B28359_01/server.111/b28318/physical.htm#CNCPT1082

从 Oracle 内部管理数据的角度，可以将 Oracle 分为4个组件：
1. 表空间(tablespace)
   - 最基本的逻辑结构，是 Oracle 中进行数据恢复的最小单位，容纳着表、索引等对象
   - 数据库是由若干表空间组成的。一个表空间至少对应一个物理文件。
   - 实际开发中，不建议使用默认表空间。请为自己的业务创建自己的表空间。
   #+BEGIN_SRC sql
     -- 内置的各种表空间
     ---- system/sysaux 系统表空间/系统辅助表空间，用来保存系统字典表和其他信息，数据库创建完会自动生成
     ---- users 用户表空间，创建新用户时，默认使用的表空间
     ---- temp 临时表空间
     ---- undo 回滚表空间

     -- 查看表空间信息
     select * from v$tablespace;

     -- 查看所有表空间跟文件对应关系
     SELECT  FILE_NAME, BLOCKS, TABLESPACE_NAME from dba_data_files;

     -- 创建表空间
     create tablespace xxx
       datafile   'D:/sss.dbf'
       size       50m
       autoextend on
       next       50m
       maxsize    1024m;

     -- 创建临时表空间
     create temporary tablespace yyy
       tempfile 'D:/ANOTHER_TMP.dbf'
       size 5m;

     -- 删除表空间
     drop tablespace xxx;
   #+END_SRC
2. 段(Segment)
   - 段是对象在数据库中占用的空间
   - 包括索引段、数据段等
   - 表空间被划分为若干区域，每个区域负责存放不同类型数据，这些区域这就是段
3. 区(Extend)
   - 由连续的数据块组成，由 Oracle 自动分配管理
   - 会自动扩展大小
4. 块(Block)
   - 数据块是 Oracle 数据库最小的逻辑单元
   - 它代表在读写操作的时候，每次处理的数据大小是多少
   - 正常情况下，它是操作系统块的整数倍，默认是 8 KB
   - 可以通过参数 db_block_size 控制
     : show parameters block;

[[file:assets/image/database-oracle/oracle_logic_2017-08-17_14-33-06.jpg]]

* 用户权限
安装完 Oracle，缺省有两个用户：
1. =SYS= 用户，又叫数据库系统管理员、特权用户，数据库中至高无上的存在。
   - 它是数据库的系统管理员，负责数据库的安装、维护、升级、备份、恢复、优化等操作。
   - 在它之下，保存着数据库所有的系统字典。
   - 不能用 normal 身份登录，必须用 SYSDBA/SYSOPER 身份登录。
2. =SYSTEM= 用户，数据库管理员，它拥有 DBA 角色，主要负责对数据库中各种对象，各种资源的管理。
3. =SCOTT= 用户，一个示例用户，默认是锁定的，需要解锁使用。

新创建的用户，是不能做任何事情的（甚至不能登录）。
必须要为用户授予权限，才能做相应的事情。
可以说，用户是权限的容器。

权限分为两种：
#+BEGIN_SRC dot :file assets/dot/oracle_privs.jpg :exports results
  digraph xxoo {
      ranksep=.3;

      node [shape=Mrecord,fontname=SimSun,fontsize=12,style=filled];
      Privs [label=" 权限 ",fillcolor=orange];
      SysPriv [label=" 系统权限 ",fillcolor=lightyellow,color=red];
      TabPriv [label=" 对象权限 ",fillcolor=lightyellow,color=red];
      Role [label=" 角色 "];

      Privs -> { SysPriv,TabPriv } -> Role [color=gray];

      node [shape=none,fontsize=10];
      a [label="- 系统权限。执行特定命令和实施特定行为的权限。\l- 对象权限。作用在某个数据库对象上的权限，包括对对象的增删改查。\n- 角色。为了方便管理，将若干系统权限打包统一分配，称之为角色。\l"];
      b [label="授权、撤销授权:\lgrant x [on y] to z [with admin/grant option];\lrevoke x from z;\l"];
      c [label="查看已授权情况:\lselect * from dba_sys_privs;\lselect * from dba_tab_privs;\lselect * from dba_role_privs;\l"];
      d [label="所有系统权限、角色:\lselect * from system_privilege_map;\lselect * from dba_roles;\l"];

      a -> b -> c [style=invis];
      Role -> d [style=invis];
  }
#+END_SRC

#+RESULTS:
[[file:assets/dot/oracle_privs.jpg]]

** 用户(User)
用户是用于 *资源管理* 和 *权限控制* 的一个概念。

#+BEGIN_SRC sql
  -- 创建用户的语法
  CREATE USER name
    IDENTIFIED BY password          -- 一个用户，至少拥有用户名和密码
    [DEFAULT TABLESPACE users]      -- 指定此用户下数据默认保存位置，如果不指定，默认为 Users 表空间
    [TEMPORARY TABLESPACE temp]     -- 指定临时表空间，默认为 temp 表空间
    [QUOTA 100M/unlimited ON USERS] -- 在表空间上有多少空间的使用权力，默认为 0, unlimited 表示无上限
    [ACCOUNT LOCK/UNLOCK]           -- 账号的初始状态：锁定/未锁定，默认为未锁定
    [PASSWORD EXPIRE]               -- 账号的初始状态：强制要求重设密码，默认不强制
    [PROFILE DEFAULT]               -- 指定使用的资源文件，默认是 default
  ;

  -- 修改用户的语法
  ALTER USER name [跟创建用户的参数是一样的];

  -- 删除用户的语法
  DROP USER name [cascade];
#+END_SRC

为了对用户行为有更精细的控制，需要使用 *资源文件* (=profile=)。
资源文件是口令限制、资源限制的命名集合。

#+BEGIN_SRC sql
  -- 增加资源文件的语法
  CREATE PROFILE name LIMIT
    RESOURCE_参数 n/unlimited/default  -- 控制的是资源的占用
    PASSWORD_参数;                     -- 控制的是密码的使用

  -- 修改资源文件的语法
  ALTER PROFILE name ...;

  -- 删除资源文件的语法
  DROP PROFILE name;

  -- 为用户指定资源文件
  ALTER USER name PROFILE profile_name;
#+END_SRC

常用资源文件选项：
| 名字                      | 类型     | 介绍                                      |
|---------------------------+----------+-------------------------------------------|
| SESSIONS_PER_USER         | resource | 每个用户最多能创建的连接数                |
| CONNECT_TIME              | resource | 每个连接最多能保持的时间(分钟)            |
| IDLE_TIME                 | resource | 每个连接不操作多长时间自动断开(分钟)      |
| CPU_PER_SESSION           | resource | 每个连接最多能占用的 CPU 时间(百分之一秒) |
| LOGICAL_READS_PER_SESSION | resource | 每个连接最多能读取的数据块                |
| PRIVATE_SGA               | resource | 最多占用的 SGA 大小                       |
| PASSWORD_LIFE_TIME        | password | 限制指定时间中必须重新修改密码(天)        |
| PASSWORD_REUSE_TIME/MAX   | password | 密码重用的限制                            |
| FAILED_LOGIN_ATTEMPTS     | password | 允许的密码输错次数                        |
| PASSWORD_LOCK_TIME        | password | 因输错密码锁定的天数(天)                  |
| PASSWORD_VERIFY_FUNCTION  | password | 用于自定义密码验证                        |
  

操作示例：
#+BEGIN_SRC sql
  -- 所有的用户信息，保存在字典表 dba_users 里面
  select * from dba_users where USERNAME='VIP';
  -- 所有的资源文件信息，保存在 dba_profiles 里面
  select * from dba_profiles where profile='DEFAULT';


  -- 创建用户的最基本语句，需要用户名和密码
  -- 其他属性采用的都是默认值
  create user vip identified by vip;


  -- 再一个稍微复杂一点的创建语句
  create user vip
    identified by vip
    default tablespace users
    temporary temporary temp
    quota unlimited on users
    password expire;


  -- 在实际环境中，一个良好的习惯是：
  -- 为我们新建的用户创建独立的表空间
  create tablespace db_vip
    datafile 'd:/db_vip.dbf'
    size 50m;

  create user vip
    identified by vip
    default tablespace db_vip
    quota unlimited on db_vip
    password expire;


  -- 如果想对用户做一些限制
  -- 需要为它创建相应的资源文件
  create profile vip_profile limit
    failed_login_attempts 3
    password_life_time    unlimited
    sessions_per_user     2;
 
 -- 将资源文件分配给用户，也可以在创建用户的时候指定
  alter user profile vip_profile;
#+END_SRC

** 权限(Privilege)

*权限指的是执行特定命令或访问数据库对象的权利，分为系统权限和对象权限。*
#+BEGIN_SRC sql
  -- 授权
  -- with admin option 可以允许获得权限的用户可以将这个权限继续授予别人
  GRANT 权限 [ON 对象] TO 谁 [WITH ADMIN OPTION];

  -- 撤销授权
  REVOKE 权限 FROM 谁;

  -- 创建角色
  CREATE ROLE 角色名;
#+END_SRC

操作示例：
#+BEGIN_SRC sql
  -- 对象权限有 select/insert/update/delete/alter/execute 等
  -- 系统中所有的系统权限和角色保存在相关字典表中:
  select * from system_privilege_map;  -- 列出系统中所有的系统权限
  select * from dba_role;              -- 列出系统中所有的角色


  -- 查看已授予的权限
  select * from dba_sys_privs where grantee='VIP';
  select * from dba_tab_privs where grantee='VIP';
  select * from dba_role_privs where grantee='VIP';


  --- 关于权限的管理
  -- 新建用户先
  create user vip identified by vip quota 1m on users;
  -- 新用户什么都干不了，甚至不能登录，如果想让它可以登录，给它一个相应权限：
  grant create session to vip;
  -- 现在可以登录 vip 了。但是不能创建表，需要我们给一个相应权限：
  grant create table to vip;
  -- 现在，可以创建表了
  create table aaa (i int);
  insert into aaa values (888);
  commit;
  -- 上面创建用户、授权的语句可以缩写为：
  grant create session, create table to vip identified vip quota 1m on user;
  -- 自己创建的表，自己会有完全的操作权力，但如果想要看别的用户的表，需要授权：
  grant select on scott.emp to vip;
  -- 上面就有了查询的权限。但不能修改。如果要修改，需要相应权限。当然，如果想把对象上的所有权力一并授予，需要用到 All:
  grant all on scott.emp to vip;
  -- 通过下面语句，可以看到对象权限的授予情况：
  select * from dba_tab_privs where grantee='VIP';

#+END_SRC

*角色是权限的命名集合，它可以简化授权。*
#+BEGIN_SRC sql
  -- 创建角色
  create role myrole;
  -- 将权限赋予角色
  grant create session, create table to myrole;
  grant create view to myrole;
  -- 甚至可以将另一个角色赋予我们的角色
  grant resource to myrole;
  -- 使用角色
  grant myrole to vip;
  grant myrole to vip with admin option;
  -- 删除角色
  drop role myrole;
#+END_SRC

*[Oracle 预定义角色]* Oracle 自带了很多角色，常用的有：
1. CONNECT，只包含了 create session 等权限，即登录系统的权限
   : select * from dba_sys_privs where grantee='CONNECT';
2. RESOURCE，包含了若干 create xxx 权限，即创建对象、创建资源的权限
   : select * from dba_sys_privs where grantee=RESOURCE';
3. DBA，包含了200多个系统权限，是用来进行系统管理的角色
   : grant connect, resource to A_Common_User;
   : grant dba to A_Super_User;

*[特殊的 PUBLIC 角色]* 公用角色，默认是授予每个用户的。
: grant connect to public;  -- 这样，不需要进行任何其他操作，所有新建的用户就都拥有登录的功能了。

*[最小权限原则]* 我们开发的时候，为了方便，经常要做这样的操作：
: grant dba to xxx identified by yyy;  -- 创建一个用户 xxx，密码为 yyy，授予 dba 角色

但这权力太大，在正式环境中，这样的授权是非常不合适的。一般要遵守 =最小权限原则=, 也就是：
: 创建一个用户，授予能完成任务的尽量少的权限，多一个也不好。


比如，我们有客户需要查看 vip 用户下的 student 表，我们需要创建一个用户给他：
#+BEGIN_SRC sql
  -- 第一步，为客户需求创建一个用户
  create user guest identified by ***;

  -- 第二步，授予连接数据库的权限
  grant connect to guest;

  -- 第三步，授予 vip.student 的 select 权限
  grant select on vip.student to guest;


  -- 当然，上面可以再简化为以下。That's All.
  grant connect to guest identified by ***;
  grant select on vip.student to guest;
#+END_SRC

* SQL 语句
** Data Type
#+BEGIN_SRC dot :file assets/dot/oracle_dataType.jpg :exports results
  digraph dt {
      rankdir=LR;
      edge [color=grey];
      node [shape=Mrecord,fontname=SimSun,fontsize=10,style=filled,fillcolor=lightskyblue];
      DataType [label="Oracle 数据类型",fillcolor=pink];
      {
        node [fillcolor=lightyellow];
        Numeric [label=" 数字类型 "];
        Character [label=" 字符类型 "];
        DATEType [label=" 日期类型 "];
        RAWType [label=" 二进制类型 "];
        LOB [label=" Lob 类型 "];
      }

      {
        CHAR;
        VARCHAR [label="VARCHAR/VARCHAR2"];
      }

      DataType -> { Numeric, Character, DATEType, RAWType, LOB, "ROWID/ROWNUM" };
      Numeric -> NUMBER -> { Integer, Float };
      Character -> { CHAR, VARCHAR, Long };
      CHAR -> NCHAR;
      VARCHAR -> NVARCHAR;
      DATEType -> { DATE, TIMESTAMP, "TIMESTAMP with Time Zone" };
      RAWType -> { RAW, LongRAW };
      LOB -> { CLOB, BLOB, BFile }
  }
#+END_SRC

#+RESULTS:
[[file:assets/dot/oracle_dataType.jpg]]

* Objects
* PL/SQL编程
* 锁/事务
* hint/explain
* Miscellaneous
** 操作系统历史 (Operate System History)
#+BEGIN_SRC dot :file assets/dot/os_history.jpg :exports results
  digraph os_history {
      graph [rankdir=LR,ranksep=.25];
      node [shape=Mrecord,color=lightblue,fontname=SimSun,fontsize=10,style=filled,fillcolor=aliceblue];
      edge [fontname=SimSun,fontsize=9,color=grey,arrowhead=vee,arrowsize=.5];

      OS -> { Windows[label="Windows\nMicrosoft"]; UNIX };
      
      UNIX -> TM [label="拓展/商用",constraint=false];
      UNIX -> BSD [label="开源版本\n(加州大学伯克利分校)"];
      UNIX -> Linux[label="山寨版本\n(by Linus Torvalds)"];

      BSD -> { TM, FreeBSD, OpenBSD, NetBSD };
      TM -> { "AIX(IBM)", "Solaris(Oracle)", "MacOS(Apple)", "HP-UX(HP)" };

      {
          node [shape=plaintext,style=none];
          FreeBSD_Desc [label="稳定，高效，精于网络处理"];
          OpenBSD_Desc [label="号称最安全的操作系统"];
          NetBSD_Desc  [label="可移植性强，适合嵌入式"];
      }

      FreeBSD -> FreeBSD_Desc;
      OpenBSD -> OpenBSD_Desc;
      NetBSD -> NetBSD_Desc;

      linuxDist [label=" GNU/Linux 发行版 "];
      
      Linux -> linuxDist [label="预装大量软件\n增强易用性"];
      linuxDist -> { Android; Archlinux; }
      linuxDist -> { node[color=darkgreen]; Debian; Ubuntu; Kali; }
      linuxDist -> { node[color=steelblue]; Redhat; Fedora; CentOS; };
      Linux -> GNU [label="推动者"];
      GNU -> linuxDist [style=dotted];
      GNU -> { "GNU's Not Unix 的缩写",
               "由 Richard Stallman\n在麻省理工学院\n人工智能实验室发起,\n目标是成立一个\n完全免费的操作系统",
               "自由软件组织\n口号是：开源，自由" };

  }
      
#+END_SRC

#+RESULTS:
[[file:assets/dot/os_history.jpg]]



