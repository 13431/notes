#+TITLE: Hibernate

* 序
创建 hibernate 工程示例：
1. 创建工程，引入 jar 包
2. 创建配置文件 hibernate.cfg.xml, 配置数据库连接
3. 编写实体类(=entity=), 标明注解, 然后配置在 hibernate.cfg.xml 中
4. 创建 =SessionFactory=, 获取 =Session=, 通过操作实体类操作数据库。
* Session
对象的三种状态：
1. =Transient=, 瞬时状态，指的是对象已经被初始化，但没有跟 hibernate 的 session 建立过联系，即数据库里没有数据对应。
2. =Persistent=, 持久化状态，指的是对象在数据中有对应数据，对象有 id 值。它可能是通过 save 或 load 等方式得到的，并且在 session 缓存中有定义。
3. =Detached=, 脱管状态，曾经被持久，在数据库中有数据对应。但是，在 session 缓存里没有记录。也许是 session 关闭了，也许是清空了。

状态之间可以进行转换，下面是大致的转换流程：
#+DOWNLOADED: file:E%3A/downloads/hibernate_ostatus.svg @ 2017-09-21 10:08:32
[[file:assets/image/orm-hibernate/hibernate_ostatus_2017-09-21_10-08-32.svg]]


** get/load/query()
- get/load 会优先在 session 缓存里寻找对象，如果找不到，再去查询数据库
- query 会直接查询数据库
- get 不懒，会立刻查询。如果没有找到，那么返回 null
- load 延迟加载，立刻返回一个代理对象。如果没有找到，那么抛出异常
- =LazyInitializationException= !!!

** flush/refresh()
flush 将 session 缓存里的数据同步到数据库，触发相应的 sql 语句。

以下情况，会触发 flush 操作：
1. 调用 commit 的时候，会触发 session.flush() 操作。
2. 执行 session.createQuery() 查询的时候，也会触发 flush 操作。
3. 手动执行 flush 操作。

refresh 是将数据库里的信息，同步到 session 缓存。

** clear/evict()
从 session 缓存中清理数据

** save/persist()
都是用来将瞬时对象变为持久化对象，即将数据插入数据库，对应 insert 语句。

save 是 hibernate 原生的语法，persist 是 jpa 的语法。

在执行的时候，不会立刻插入数据，只有执行了 flush 操作，才真正触发数据库操作。

save/persist 方法会立刻为实体类对象生成主键。

他们的区别是, 如果在保存之前，重新手动赋予了主键：
1. save 会忽视你的赋值
2. persist 会抛异常

** update/merge()
- 他们主要用来完成实体类对象的修改，对应的是 update 语句。
- 若更新一个持久化对象，可以不显式调用 update, 因为 flush 操作会触发 update
- 可以将一个脱管对象转换为持久化对象
- merge 是 jpa 中的语法

** doWork
可以将 jdbc 的 connection 对象暴露出来，用于插入一些 jdbc 操作语法。




* Identifier
#+BEGIN_SRC sql
  -- JPA 默认
  @GeneratedValue(strategy = GenerationType.AUTO/IDENTITY/SEQUENCE/TABLE)

  -- JPA 定制序列/Table
  @GeneratedValue(generator = "xxx")
  @SequenceGenerator(name = "xxx", sequenceName = "seq_xxx", associateSize = 1)
  @TableGenerator(name = "xxx", table = "tb_xxx")

  -- Hibernate 格式的 generator:
  @GeneratedValue(generator = "yyy")
  @GenericGenerator(name = "yyy", strategy = "native")
  @GenericGenerator(name = "yyy", strategy = "uuid2")
  @GenericGenerator(name = "yyy", strategy = "table")

#+END_SRC

* Association
** 1-N
** M-N
- 多对多的关系，需要使用中间表维护双方关系。对应的注解为 =@ManyToMany=
- 必须为双方制定从属关系，也就是将维护关系的责任交给其中一个实体类(=mappedBy=)，从而避免重复或冲突。
- 可以使用 =@JoinTable= 对中间表进行定制

例子：
#+BEGIN_SRC java
  @Entity
  public class Emp {
      @ManyToMany   // 负责关系的维护
      @JoinTable(...)
      private Set<Project> projects = new HashSet<>();
  }

  @Entity
  public class Project {
      @ManyToMany(mappedBy = "projects")  // 甩手掌柜
      private Set<Emp> emps = new HashSet<>();
  }
#+END_SRC

** 1-1
两种方式：
1. 在其中一个表上创建一个列，保存另一个表的主键。即外键关联。
2. 两个表，有关联的数据，使用相同的主键。即主键关联。

*外键关联:*
#+BEGIN_SRC java
  @Entity
  public class Person {
      @Id @GeneratedValue  // 主键自动生成
      private long id;
      
      @OneToOne @JoinColumn   // 负责维护外键
      private IdCard idcard;
  }

  @Entity
  public class IdCard {
      @Id @GeneratedValue // 主键自动生成
      private long id;
      
      @OneToOne(mappedBy="idcard")  // 甩手掌柜
      private Person person;
  }
#+END_SRC

*主键关联:*
#+BEGIN_SRC java
  @Entity
  public class Person {
      @Id       // 主键*不要*自动生成!!
      private long id;
      
      @OneToOne // 负责维护外键，将外键映射到主键。即将另一张表的外键映射到本表的主键。
      @MapsId @JoinColumn(name = "id") 
      private IdCard idcard;
  }

  @Entity
  public class IdCard {
      @Id @GeneratedValue // 主键自动生成
      private long id;
      
      @OneToOne(mappedBy="idcard")  // 甩手掌柜
      private Person person;
  }
#+END_SRC
* Inheritance
** SINGLE_TABLE
所有的子类跟父类使用一张表，用 dtype 来分辨各个子类。

这是默认的继承策略。
#+BEGIN_SRC java
  @Entity
  @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
  @DiscriminatorColumn(name = "xxx") // 可以定制分割列的名字
  public class Animal {}

  @Entity
  @DiscriminatorValue("狗") // 可以定制
  public class Dog extend Animal {}
#+END_SRC

特点：
- 使用了区别的列
- 只使用了一张表，所以查询速度快
- 缺点：子类的独有列，不能添加唯一/非空约束
- 缺点：使用了太多的冗余字段

** JOIN
#+BEGIN_SRC java
  @Entity
  @Inheritance(strategy = InheritanceType.JOINED)
  public class Animal { }

  @PrimaryKeyJoinColumn(name = "xxxxid")  // 可以定制关联主键
  public class Dog extend Animal { }
#+END_SRC

总结：
- 优点：数据没有任何冗余
- 缺点：查询的效率低

** PER_CLASS(union)
每个类对应一张表，大家互相隔离，各自为政

#+BEGIN_SRC java
  @Entity
  @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
  public class Animal { }

  @Entity
  public class Dog extend Animal { }
#+END_SRC

总结：
- 缺点：存在冗余字段
- 缺点：如果要更新父类中的字段，每个子表都需要去更新
- 优点：独立，自由，查询快
- 如果只查询子类，那么不需要任何关联；但如果查询父类的话，需要
** MappedSuperClass
如果父类不是 Entity，只是为了提供子类的属性，那么，将其注解为 =@Mappedsuperclass= 即可

#+BEGIN_SRC java
  @MappedSuperclass
  abstract public class Person {
      private String name;
  }

  @Entity
  public class Girl extend Person {
      private String wechat;
  }

  @Entity
  public class Boy extend Person {
      private String address;
  }
      
#+END_SRC

